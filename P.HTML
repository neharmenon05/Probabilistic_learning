<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bayesian Housing Price Studio</title>

<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
  #mini-map { height: 220px; width: 100%; }
  .probability-bar { transition: width 0.8s ease-in-out; }
  .chart-card { min-height: 240px; }
  .woe-badge { font-variant-numeric: tabular-nums; }
  .history-row:hover { background: rgba(59, 130, 246, 0.05); }
  @media (max-width: 800px) { .chart-card { min-height: 200px; } }
  .small-note { font-size: 12px; color: #6b7280; }
  .tool-description { 
    background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
    border-left: 4px solid #3b82f6;
    padding: 8px 12px;
    margin: 8px 0;
    border-radius: 4px;
    font-size: 13px;
    color: #475569;
  }
  .feature-importance { 
    background: linear-gradient(90deg, #ecfdf5 0%, #d1fae5 100%);
    border: 1px solid #10b981;
    border-radius: 6px;
    padding: 8px;
  }
  .error-display {
    background: #fef2f2;
    border: 1px solid #fecaca;
    color: #dc2626;
    padding: 8px;
    border-radius: 4px;
    font-size: 12px;
  }
</style>
</head>
<body class="bg-gray-50 text-gray-800">

<!-- Header -->
<header class="bg-gradient-to-r from-blue-600 via-purple-600 to-indigo-700 text-white p-4 shadow-lg">
  <div class="container mx-auto flex items-center justify-between">
    <div class="flex items-center gap-4">
      <div class="w-10 h-10 bg-white/20 rounded-full flex items-center justify-center">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"
                d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3"></path>
        </svg>
      </div>
      <div>
        <h1 class="text-2xl font-bold">Bayesian Housing Price Studio</h1>
        <div class="text-xs opacity-90">Probabilistic housing analysis with rigorous mathematical foundations</div>
      </div>
    </div>

    <div class="flex items-center gap-3">
      <button id="btn-export-csv" class="bg-white/20 hover:bg-white/30 px-3 py-1 rounded text-sm transition-colors">Export Results CSV</button>
      <button id="btn-export-pdf" class="bg-white/20 hover:bg-white/30 px-3 py-1 rounded text-sm transition-colors">Export PDF Report</button>
      <div class="text-xs opacity-75 ml-2">All processing client-side</div>
    </div>
  </div>
</header>

<main class="container mx-auto p-6 space-y-6">

  <!-- Navigation -->
  <nav class="grid grid-cols-2 md:grid-cols-4 gap-4">
    <a href="#predictor" class="bg-white p-4 rounded-lg shadow hover:shadow-md transition-shadow text-center border-l-4 border-blue-500">
      <div class="font-semibold">Predictor</div>
      <div class="text-xs text-gray-600 mt-1">Bayesian inference engine</div>
    </a>
    <a href="#train" class="bg-white p-4 rounded-lg shadow hover:shadow-md transition-shadow text-center border-l-4 border-green-500">
      <div class="font-semibold">Train & Data</div>
      <div class="text-xs text-gray-600 mt-1">Learn from your CSV data</div>
    </a>
    <a href="#simulations" class="bg-white p-4 rounded-lg shadow hover:shadow-md transition-shadow text-center border-l-4 border-purple-500">
      <div class="font-semibold">Scenarios</div>
      <div class="text-xs text-gray-600 mt-1">Risk analysis & planning</div>
    </a>
    <a href="#research" class="bg-white p-4 rounded-lg shadow hover:shadow-md transition-shadow text-center border-l-4 border-amber-500">
      <div class="font-semibold">Advanced</div>
      <div class="text-xs text-gray-600 mt-1">MCMC & time series</div>
    </a>
  </nav>

  <!-- Predictor Section -->
  <section id="predictor" class="bg-white rounded-lg shadow-lg p-6 border-t-4 border-blue-500">
    <div class="flex items-start justify-between mb-4">
      <div>
        <h2 class="text-2xl font-bold text-gray-800">Housing Price Predictor</h2>
        <div class="tool-description">
          <strong>What it does:</strong> Uses Bayesian inference to estimate housing price probabilities based on property features. 
          Supports exact inference (Variable Elimination) and approximate methods (Gibbs MCMC sampling). 
          Provides explainable predictions with feature importance analysis.
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 xl:grid-cols-3 gap-6">
      <!-- Input Panel -->
      <div class="bg-gray-50 p-5 rounded-lg border">
        <h3 class="font-semibold mb-3 flex items-center">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
          </svg>
          Property Features
        </h3>
        
        <div id="input-fields" class="grid grid-cols-2 gap-3 mb-4">
          <!-- Dynamic fields will be populated here based on CSV headers -->
        </div>

        <div class="border-t pt-4 mt-4">
          <div class="flex gap-2 items-center mb-3">
            <select id="inference-method" class="p-2 border rounded flex-grow">
              <option value="exact">Variable Elimination (Exact)</option>
              <option value="gibbs">Gibbs Sampling (MCMC)</option>
            </select>
            <input id="gibbs-iterations" type="number" min="100" max="50000" step="100" value="5000" 
                   class="p-2 border rounded w-24" title="MCMC iterations" />
            <button id="btn-run" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded font-medium transition-colors">
              Predict
            </button>
          </div>
        </div>

        <div class="border-t pt-4">
          <h4 class="font-medium mb-2">Interactive Sensitivity Analysis</h4>
          <div id="sensitivity-sliders" class="space-y-3">
            <!-- Dynamic sliders will be populated here -->
          </div>
        </div>

        <div class="border-t pt-4 mt-4">
          <div class="mb-2">
            <label class="text-sm font-medium">Analysis Name</label>
            <input id="run-name" type="text" placeholder="e.g., Downtown LA Property" 
                   class="mt-1 p-2 w-full border rounded" />
          </div>
          <div class="flex gap-2">
            <button id="btn-save-history" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm transition-colors">
              Save Analysis
            </button>
            <button id="btn-clear-history" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded text-sm transition-colors">
              Clear History
            </button>
          </div>
        </div>
      </div>

      <!-- Analysis Results -->
      <div class="bg-gray-50 p-5 rounded-lg border">
        <h3 class="font-semibold mb-3 flex items-center">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 00-2 2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v4"></path>
          </svg>
          Probability Distribution
        </h3>

        <div class="grid grid-cols-1 gap-4 mb-4">
          <div class="chart-card p-3 border rounded bg-white">
            <canvas id="barChart"></canvas>
          </div>
          <div class="chart-card p-3 border rounded bg-white">
            <canvas id="distributionChart"></canvas>
          </div>
        </div>

        <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 rounded-lg border">
          <div class="grid grid-cols-2 gap-4">
            <div>
              <div class="text-sm text-gray-600">Expected Value</div>
              <div id="expected-value" class="text-2xl font-bold text-blue-700">$0</div>
              <div class="text-xs text-gray-500">Posterior expectation</div>
            </div>
            <div>
              <div class="text-sm text-gray-600">Confidence Interval (90%)</div>
              <div id="confidence-interval" class="text-lg font-semibold text-indigo-700">-</div>
              <div class="text-xs text-gray-500">Credible interval</div>
            </div>
          </div>
        </div>

        <div class="mt-4 feature-importance">
          <h4 class="font-medium mb-2 flex items-center">
            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
            </svg>
            Feature Importance (Information Gain)
          </h4>
          <div id="woe-list" class="space-y-1 text-sm"></div>
        </div>

        <div class="mt-4 bg-gray-100 p-3 rounded">
          <h4 class="font-medium text-sm mb-2">Model Diagnostics</h4>
          <div class="text-xs text-gray-600 space-y-1" id="inference-details">
            <div>Method: <span id="inf-method-text">-</span></div>
            <div>Evidence variables: <span id="evidence-text">-</span></div>
            <div>Posterior entropy: <span id="entropy-text">-</span> bits</div>
            <div>Model confidence: <span id="confidence-text">-</span></div>
          </div>
        </div>
      </div>

      <!-- Map & Probability Visualization -->
      <div class="bg-gray-50 p-5 rounded-lg border">
        <h3 class="font-semibold mb-3 flex items-center">
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"></path>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"></path>
          </svg>
          Location & Price Probabilities
        </h3>
        
        <div id="mini-map" class="mb-4 rounded border"></div>

        <div class="space-y-3" id="probability-bars">
          <!-- Dynamic probability bars will be populated here -->
        </div>

        <div class="mt-4">
          <h4 class="font-medium mb-2">Analysis History</h4>
          <div id="history-quick" class="text-sm max-h-48 overflow-auto bg-white rounded border p-2"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- Training Section -->
  <section id="train" class="bg-white rounded-lg shadow-lg p-6 border-t-4 border-green-500">
    <div class="flex items-start justify-between mb-4">
      <div>
        <h2 class="text-2xl font-bold text-gray-800">Data Training & Model Learning</h2>
        <div class="tool-description">
          <strong>What it does:</strong> Automatically learns Bayesian network parameters from your CSV data using Maximum Likelihood Estimation with Laplace smoothing. 
          Handles any dataset by auto-detecting headers and creating optimal discretization thresholds. 
          Includes comprehensive model evaluation with cross-validation.
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div class="bg-gray-50 p-5 rounded-lg border">
        <h4 class="font-semibold mb-3">Data Upload & Configuration</h4>
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium mb-1">Upload CSV Dataset</label>
            <input id="csv-file" type="file" accept=".csv" class="w-full p-2 border rounded" />
            <div class="text-xs text-gray-600 mt-1">Supports any CSV with numeric features and a target column</div>
          </div>

          <div>
            <label class="block text-sm font-medium mb-1">Target Column Name</label>
            <select id="target-column" class="w-full p-2 border rounded">
              <option value="">Select target column...</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium mb-1">Number of Price Bins</label>
            <select id="n-bins" class="w-full p-2 border rounded">
              <option value="3">3 bins (Low/Medium/High)</option>
              <option value="4" selected>4 bins (Low/Medium/High/Luxury)</option>
              <option value="5">5 bins (Fine-grained)</option>
            </select>
          </div>

          <div>
            <label class="block text-sm font-medium mb-1">Discretization Method</label>
            <select id="discretization-method" class="w-full p-2 border rounded">
              <option value="quantile" selected>Equal Frequency (Quantiles)</option>
              <option value="equal-width">Equal Width</option>
              <option value="kmeans">K-Means Clustering</option>
            </select>
          </div>

          <div class="flex gap-2">
            <button id="btn-learn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded flex-grow transition-colors">
              Learn Model
            </button>
            <button id="btn-eval" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded flex-grow transition-colors">
              Evaluate
            </button>
          </div>
        </div>
      </div>

      <div class="bg-gray-50 p-5 rounded-lg border">
        <h4 class="font-semibold mb-3">Model Structure</h4>
        <div class="text-xs text-gray-700 max-h-80 overflow-auto space-y-2" id="cpt-preview">
          <div class="text-center text-gray-500 py-8">Upload data and click "Learn Model" to see learned parameters</div>
        </div>
      </div>

      <div class="bg-gray-50 p-5 rounded-lg border">
        <h4 class="font-semibold mb-3">Model Performance</h4>
        <div id="eval-output" class="text-sm space-y-3">
          <div class="text-center text-gray-500 py-8">Click "Evaluate" to see performance metrics</div>
        </div>
      </div>
    </div>
  </section>

  <!-- Scenarios Section -->
  <section id="simulations" class="bg-white rounded-lg shadow-lg p-6 border-t-4 border-purple-500">
    <div class="flex items-start justify-between mb-4">
      <div>
        <h2 class="text-2xl font-bold text-gray-800">Scenario Analysis & Risk Assessment</h2>
        <div class="tool-description">
          <strong>What it does:</strong> Applies trained models to real-world decision scenarios. 
          Builder tool estimates profitability and ROI. Banking tool calculates default risk probabilities. 
          Policy tool simulates market impacts of economic changes using sensitivity analysis.
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <div class="bg-gradient-to-br from-blue-50 to-blue-100 p-5 rounded-lg border border-blue-200">
        <h4 class="font-semibold text-blue-800 mb-2 flex items-center">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-4m-5 0H9m0 0H5m4 0V9a1 1 0 011-1h1m0 0V7a2 2 0 012-2h3a2 2 0 012 2v1M9 7h6m-7 9v3m8 0v-3m-1 0V9h-1m1 4h2"></path>
          </svg>
          Real Estate Developers
        </h4>
        <div class="text-sm text-blue-700 mb-3">Calculate expected ROI and profitability risk for development projects</div>
        
        <div class="space-y-3">
          <div>
            <label class="text-xs text-blue-800">Total Development Cost ($)</label>
            <input id="builder-cost" type="number" class="mt-1 p-2 w-full border rounded bg-white" value="250000" />
          </div>
          <div>
            <label class="text-xs text-blue-800">Target Profit Margin (%)</label>
            <input id="builder-margin" type="number" step="1" class="mt-1 p-2 w-full border rounded bg-white" value="25" />
          </div>
          <div>
            <label class="text-xs text-blue-800">Market Premium Factor</label>
            <input id="builder-premium" type="number" step="0.05" class="mt-1 p-2 w-full border rounded bg-white" value="1.15" />
          </div>
          <button id="btn-builder-sim" class="w-full bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm transition-colors">
            Calculate ROI
          </button>
        </div>
        <div id="builder-output" class="text-xs mt-3 p-2 bg-white rounded border"></div>
      </div>

      <div class="bg-gradient-to-br from-emerald-50 to-emerald-100 p-5 rounded-lg border border-emerald-200">
        <h4 class="font-semibold text-emerald-800 mb-2 flex items-center">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"></path>
          </svg>
          Banking & Finance
        </h4>
        <div class="text-sm text-emerald-700 mb-3">Assess loan default risk and collateral value probability</div>
        
        <div class="space-y-3">
          <div>
            <label class="text-xs text-emerald-800">Loan Amount ($)</label>
            <input id="bank-loan" type="number" class="mt-1 p-2 w-full border rounded bg-white" value="200000" />
          </div>
          <div>
            <label class="text-xs text-emerald-800">Loan-to-Value Ratio (%)</label>
            <input id="bank-ltv" type="number" step="1" class="mt-1 p-2 w-full border rounded bg-white" value="80" />
          </div>
          <div>
            <label class="text-xs text-emerald-800">Risk Threshold (%)</label>
            <input id="bank-risk" type="number" step="1" class="mt-1 p-2 w-full border rounded bg-white" value="10" />
          </div>
          <button id="btn-bank-sim" class="w-full bg-emerald-600 hover:bg-emerald-700 text-white px-3 py-2 rounded text-sm transition-colors">
            Assess Risk
          </button>
        </div>
        <div id="bank-output" class="text-xs mt-3 p-2 bg-white rounded border"></div>
      </div>

      <div class="bg-gradient-to-br from-amber-50 to-amber-100 p-5 rounded-lg border border-amber-200">
        <h4 class="font-semibold text-amber-800 mb-2 flex items-center">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2-2V7a2 2 0 012-2h2a2 2 0 002 2v2a2 2 0 002 2h2a2 2 0 012-2V7a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 00-2 2h-2a2 2 0 00-2 2v6a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
          </svg>
          Policy & Economics
        </h4>
        <div class="text-sm text-amber-700 mb-3">Simulate economic policy impacts on housing markets</div>
        
        <div class="space-y-3">
          <div>
            <label class="text-xs text-amber-800">Income Change (%)</label>
            <input id="policy-income" type="number" step="1" class="mt-1 p-2 w-full border rounded bg-white" value="5" />
          </div>
          <div>
            <label class="text-xs text-amber-800">Interest Rate Change (bps)</label>
            <input id="policy-rate" type="number" step="25" class="mt-1 p-2 w-full border rounded bg-white" value="50" />
          </div>
          <div>
            <label class="text-xs text-amber-800">Infrastructure Investment ($M)</label>
            <input id="policy-infra" type="number" step="10" class="mt-1 p-2 w-full border rounded bg-white" value="100" />
          </div>
          <button id="btn-policy-sim" class="w-full bg-amber-600 hover:bg-amber-700 text-white px-3 py-2 rounded text-sm transition-colors">
            Simulate Impact
          </button>
        </div>
        <div id="policy-output" class="text-xs mt-3 p-2 bg-white rounded border"></div>
      </div>
    </div>
  </section>

  <!-- Advanced Section -->
  <section id="research" class="bg-white rounded-lg shadow-lg p-6 border-t-4 border-amber-500">
    <div class="flex items-start justify-between mb-4">
      <div>
        <h2 class="text-2xl font-bold text-gray-800">Advanced Methods & Research Tools</h2>
        <div class="tool-description">
          <strong>What it does:</strong> Implements advanced probabilistic methods including Markov Chain Monte Carlo (MCMC) for complex inference, 
          Dynamic Bayesian Networks (DBN) for time series modeling, and ensemble methods for improved accuracy. 
          Includes convergence diagnostics and uncertainty quantification.
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div class="bg-gradient-to-br from-purple-50 to-purple-100 p-5 rounded-lg border border-purple-200">
        <h4 class="font-semibold text-purple-800 mb-2 flex items-center">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
          </svg>
          MCMC Inference Engine
        </h4>
        <div class="text-sm text-purple-700 mb-3">Markov Chain Monte Carlo for high-dimensional inference with convergence diagnostics</div>
        
        <div class="space-y-3">
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="text-xs text-purple-800">Chain Length</label>
              <input id="mcmc-iterations" type="number" min="1000" max="100000" step="1000" value="10000" class="mt-1 p-2 w-full border rounded bg-white text-sm" />
            </div>
            <div>
              <label class="text-xs text-purple-800">Burn-in (%)</label>
              <input id="mcmc-burnin" type="number" min="10" max="50" value="25" class="mt-1 p-2 w-full border rounded bg-white text-sm" />
            </div>
          </div>
          <div>
            <label class="text-xs text-purple-800">Sampling Method</label>
            <select id="mcmc-method" class="mt-1 p-2 w-full border rounded bg-white">
              <option value="gibbs">Gibbs Sampling</option>
              <option value="metropolis">Metropolis-Hastings</option>
              <option value="slice">Slice Sampling</option>
            </select>
          </div>
          <button id="btn-mcmc-run" class="w-full bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm transition-colors">
            Run MCMC Analysis
          </button>
        </div>
        <div id="mcmc-output" class="text-xs mt-3 p-2 bg-white rounded border"></div>
      </div>

      <div class="bg-gradient-to-br from-indigo-50 to-indigo-100 p-5 rounded-lg border border-indigo-200">
        <h4 class="font-semibold text-indigo-800 mb-2 flex items-center">
          <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
          </svg>
          Dynamic Bayesian Networks
        </h4>
        <div class="text-sm text-indigo-700 mb-3">Time-series modeling for housing market dynamics and forecasting</div>
        
        <div class="space-y-3">
          <div>
            <label class="text-xs text-indigo-800">Time Column</label>
            <select id="time-column" class="mt-1 p-2 w-full border rounded bg-white">
              <option value="">Select time column...</option>
            </select>
          </div>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <label class="text-xs text-indigo-800">Forecast Steps</label>
              <input id="dbn-steps" type="number" min="1" max="60" value="12" class="mt-1 p-2 w-full border rounded bg-white text-sm" />
            </div>
            <div>
              <label class="text-xs text-indigo-800">Window Size</label>
              <input id="dbn-window" type="number" min="2" max="12" value="6" class="mt-1 p-2 w-full border rounded bg-white text-sm" />
            </div>
          </div>
          <button id="btn-dbn-sim" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded text-sm transition-colors">
            Build Time Series Model
          </button>
        </div>
        <div id="dbn-output" class="text-xs mt-3 p-2 bg-white rounded border"></div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="bg-gradient-to-r from-gray-800 to-gray-900 text-white py-8 rounded-lg shadow-lg">
    <div class="container mx-auto text-center">
      <div class="text-lg font-semibold mb-2">Bayesian Housing Price Studio</div>
      <div class="text-sm opacity-75 mb-4">Advanced probabilistic modeling for real estate analysis</div>
      <div class="text-xs opacity-60">
        Built with rigorous mathematical foundations • All processing client-side • No data transmitted
      </div>
    </div>
  </footer>
</main>

<script>
/* ===================================================================
   MATHEMATICAL FOUNDATIONS & UTILITIES
   =================================================================== */

// Mathematical utilities
const MathUtils = {
  clamp: (v, a, b) => Math.max(a, Math.min(b, v)),
  round: (v, places = 2) => Math.round(v * Math.pow(10, places)) / Math.pow(10, places),
  
  // Log-sum-exp for numerical stability
  logSumExp: (arr) => {
    const max = Math.max(...arr);
    const sum = arr.reduce((acc, x) => acc + Math.exp(x - max), 0);
    return max + Math.log(sum);
  },
  
  // Entropy calculation
  entropy: (probs) => {
    return -probs.reduce((acc, p) => p > 0 ? acc + p * Math.log2(p) : acc, 0);
  },
  
  // KL divergence
  klDivergence: (p, q) => {
    return p.reduce((acc, pi, i) => pi > 0 ? acc + pi * Math.log(pi / (q[i] + 1e-12)) : acc, 0);
  },
  
  // Quantiles for discretization
  quantiles: (data, n) => {
    const sorted = [...data].sort((a, b) => a - b);
    const thresholds = [];
    for (let i = 1; i < n; i++) {
      const idx = Math.floor((i / n) * sorted.length);
      thresholds.push(sorted[idx]);
    }
    return thresholds;
  },
  
  // K-means discretization
  kmeans: (data, k, maxIters = 100) => {
    let centroids = [];
    const range = Math.max(...data) - Math.min(...data);
    for (let i = 0; i < k; i++) {
      centroids.push(Math.min(...data) + (range / k) * (i + 0.5));
    }
    
    for (let iter = 0; iter < maxIters; iter++) {
      const clusters = Array.from({length: k}, () => []);
      
      // Assign points to nearest centroid
      data.forEach(point => {
        let minDist = Infinity, bestCluster = 0;
        centroids.forEach((centroid, i) => {
          const dist = Math.abs(point - centroid);
          if (dist < minDist) {
            minDist = dist;
            bestCluster = i;
          }
        });
        clusters[bestCluster].push(point);
      });
      
      // Update centroids
      let converged = true;
      centroids.forEach((centroid, i) => {
        if (clusters[i].length > 0) {
          const newCentroid = clusters[i].reduce((a, b) => a + b, 0) / clusters[i].length;
          if (Math.abs(newCentroid - centroid) > 1e-6) converged = false;
          centroids[i] = newCentroid;
        }
      });
      
      if (converged) break;
    }
    
    // Return thresholds between centroids
    centroids.sort((a, b) => a - b);
    const thresholds = [];
    for (let i = 0; i < centroids.length - 1; i++) {
      thresholds.push((centroids[i] + centroids[i + 1]) / 2);
    }
    return thresholds;
  }
};

/* ===================================================================
   BAYESIAN NETWORK CORE
   =================================================================== */

class BayesianNetwork {
  constructor() {
    this.features = [];
    this.targetColumn = null;
    this.thresholds = {};
    this.priorDist = [];
    this.conditionalDists = {};
    this.nBins = 4;
    this.learned = false;
    this.targetBins = [];
  }
  
  // Auto-detect dataset structure and create appropriate discretization
  learnFromData(data, targetCol, nBins = 4, discretizationMethod = 'quantile') {
    this.targetColumn = targetCol;
    this.nBins = nBins;
    
    // Extract features (all numeric columns except target)
    const sample = data[0] || {};
    this.features = Object.keys(sample).filter(key => 
      key !== targetCol && 
      data.some(row => !isNaN(parseFloat(row[key])))
    );
    
    console.log(`Learning from ${data.length} samples with ${this.features.length} features`);
    
    // Learn target discretization
    const targetValues = data.map(row => parseFloat(row[targetCol])).filter(v => !isNaN(v));
    this.targetBins = this.createDiscretization(targetValues, nBins, discretizationMethod);
    
    // Learn feature discretizations
    this.features.forEach(feature => {
      const values = data.map(row => parseFloat(row[feature])).filter(v => !isNaN(v));
      if (values.length > 0) {
        this.thresholds[feature] = this.createDiscretization(values, 3, discretizationMethod);
      }
    });
    
    // Learn probability distributions
    this.learnDistributions(data);
    this.learned = true;
  }
  
  createDiscretization(values, nBins, method) {
    switch (method) {
      case 'quantile':
        return MathUtils.quantiles(values, nBins);
      case 'equal-width':
        const min = Math.min(...values);
        const max = Math.max(...values);
        const width = (max - min) / nBins;
        return Array.from({length: nBins - 1}, (_, i) => min + (i + 1) * width);
      case 'kmeans':
        return MathUtils.kmeans(values, nBins);
      default:
        return MathUtils.quantiles(values, nBins);
    }
  }
  
  discretizeValue(value, thresholds) {
    if (value === null || value === undefined || isNaN(value)) return null;
    for (let i = 0; i < thresholds.length; i++) {
      if (value < thresholds[i]) return i;
    }
    return thresholds.length;
  }
  
  discretizeTarget(value) {
    return this.discretizeValue(value, this.targetBins);
  }
  
  learnDistributions(data) {
    // Laplace smoothing parameter
    const alpha = 1.0;
    
    // Learn prior P(target)
    const targetCounts = new Array(this.nBins).fill(alpha);
    const featureCounts = {};
    
    // Initialize feature counts
    this.features.forEach(feature => {
      featureCounts[feature] = Array.from({length: this.nBins}, () => 
        new Array(3).fill(alpha)
      );
    });
    
    let validSamples = 0;
    
    // Count occurrences
    data.forEach(row => {
      const targetVal = parseFloat(row[this.targetColumn]);
      if (isNaN(targetVal)) return;
      
      const targetBin = this.discretizeTarget(targetVal);
      if (targetBin === null) return;
      
      targetCounts[targetBin]++;
      validSamples++;
      
      this.features.forEach(feature => {
        const featureVal = parseFloat(row[feature]);
        if (isNaN(featureVal)) return;
        
        const featureBin = this.discretizeValue(featureVal, this.thresholds[feature]);
        if (featureBin !== null && featureCounts[feature][targetBin]) {
          featureCounts[feature][targetBin][featureBin]++;
        }
      });
    });
    
    // Normalize to probabilities
    const totalCount = targetCounts.reduce((a, b) => a + b, 0);
    this.priorDist = targetCounts.map(count => count / totalCount);
    
    // Learn conditional distributions P(feature | target)
    this.conditionalDists = {};
    this.features.forEach(feature => {
      this.conditionalDists[feature] = {};
      for (let targetBin = 0; targetBin < this.nBins; targetBin++) {
        const counts = featureCounts[feature][targetBin];
        const sum = counts.reduce((a, b) => a + b, 0);
        this.conditionalDists[feature][targetBin] = counts.map(c => c / sum);
      }
    });
    
    console.log(`Learned distributions from ${validSamples} valid samples`);
  }
  
  // Exact inference using Naive Bayes assumption
  inferExact(evidence) {
    if (!this.learned) {
      console.warn('Model not trained yet');
      return new Array(this.nBins).fill(1 / this.nBins);
    }
    
    // Start with prior
    let logPosterior = this.priorDist.map(p => Math.log(p + 1e-12));
    
    // Apply evidence
    this.features.forEach(feature => {
      const value = evidence[feature];
      if (value === null || value === undefined || isNaN(value)) return;
      
      const discretized = this.discretizeValue(value, this.thresholds[feature]);
      if (discretized === null) return;
      
      for (let targetBin = 0; targetBin < this.nBins; targetBin++) {
        const conditionalDist = this.conditionalDists[feature][targetBin];
        if (conditionalDist && conditionalDist[discretized] !== undefined) {
          logPosterior[targetBin] += Math.log(conditionalDist[discretized] + 1e-12);
        }
      }
    });
    
    // Normalize using log-sum-exp for numerical stability
    const logZ = MathUtils.logSumExp(logPosterior);
    return logPosterior.map(lp => Math.exp(lp - logZ));
  }
  
  // MCMC inference using Gibbs sampling
  inferMCMC(evidence, iterations = 10000, burnin = 0.25, method = 'gibbs') {
    const burninSamples = Math.floor(iterations * burnin);
    const samples = [];
    
    // Initialize sample
    let currentSample = Math.floor(Math.random() * this.nBins);
    
    for (let iter = 0; iter < iterations; iter++) {
      if (method === 'gibbs') {
        // Gibbs sampling: sample from exact conditional
        const posterior = this.inferExact(evidence);
        const r = Math.random();
        let cumSum = 0;
        for (let i = 0; i < posterior.length; i++) {
          cumSum += posterior[i];
          if (r <= cumSum) {
            currentSample = i;
            break;
          }
        }
      } else if (method === 'metropolis') {
        // Metropolis-Hastings
        const proposal = Math.floor(Math.random() * this.nBins);
        const currentLogProb = this.logProbability(currentSample, evidence);
        const proposalLogProb = this.logProbability(proposal, evidence);
        
        const alpha = Math.min(1, Math.exp(proposalLogProb - currentLogProb));
        if (Math.random() < alpha) {
          currentSample = proposal;
        }
      }
      
      if (iter >= burninSamples) {
        samples.push(currentSample);
      }
    }
    
    // Convert samples to empirical distribution
    const counts = new Array(this.nBins).fill(0);
    samples.forEach(s => counts[s]++);
    return counts.map(c => c / samples.length);
  }
  
  logProbability(targetBin, evidence) {
    let logProb = Math.log(this.priorDist[targetBin] + 1e-12);
    
    this.features.forEach(feature => {
      const value = evidence[feature];
      if (value === null || value === undefined || isNaN(value)) return;
      
      const discretized = this.discretizeValue(value, this.thresholds[feature]);
      if (discretized === null) return;
      
      const conditionalDist = this.conditionalDists[feature][targetBin];
      if (conditionalDist && conditionalDist[discretized] !== undefined) {
        logProb += Math.log(conditionalDist[discretized] + 1e-12);
      }
    });
    
    return logProb;
  }
  
  // Feature importance using information gain
  computeFeatureImportance(evidence) {
    const basePosterior = this.inferExact(evidence);
    const baseEntropy = MathUtils.entropy(basePosterior);
    
    const importances = [];
    
    this.features.forEach(feature => {
      const value = evidence[feature];
      if (value === null || value === undefined || isNaN(value)) {
        importances.push({ feature, importance: 0, note: 'missing' });
        return;
      }
      
      // Posterior without this feature
      const evidenceReduced = { ...evidence };
      delete evidenceReduced[feature];
      const reducedPosterior = this.inferExact(evidenceReduced);
      const reducedEntropy = MathUtils.entropy(reducedPosterior);
      
      // Information gain
      const importance = reducedEntropy - baseEntropy;
      const discretized = this.discretizeValue(value, this.thresholds[feature]);
      
      importances.push({
        feature,
        importance,
        note: `bin=${discretized}, IG=${MathUtils.round(importance, 3)}`
      });
    });
    
    return importances.sort((a, b) => b.importance - a.importance);
  }
  
  // Model evaluation with cross-validation
  evaluate(data, folds = 5) {
    const shuffled = [...data].sort(() => Math.random() - 0.5);
    const foldSize = Math.floor(shuffled.length / folds);
    
    let totalAccuracy = 0;
    let totalLogLikelihood = 0;
    const confusionMatrix = Array.from({length: this.nBins}, () => 
      new Array(this.nBins).fill(0)
    );
    
    for (let fold = 0; fold < folds; fold++) {
      const start = fold * foldSize;
      const end = fold === folds - 1 ? shuffled.length : start + foldSize;
      
      const testSet = shuffled.slice(start, end);
      const trainSet = [...shuffled.slice(0, start), ...shuffled.slice(end)];
      
      // Train on fold
      const foldNetwork = new BayesianNetwork();
      foldNetwork.learnFromData(trainSet, this.targetColumn, this.nBins);
      
      // Evaluate on test set
      let foldCorrect = 0;
      let foldLogLikelihood = 0;
      
      testSet.forEach(row => {
        const evidence = {};
        this.features.forEach(feature => {
          evidence[feature] = parseFloat(row[feature]);
        });
        
        const posterior = foldNetwork.inferExact(evidence);
        const predicted = posterior.indexOf(Math.max(...posterior));
        const actual = foldNetwork.discretizeTarget(parseFloat(row[this.targetColumn]));
        
        if (actual !== null) {
          if (predicted === actual) foldCorrect++;
          foldLogLikelihood += Math.log(posterior[actual] + 1e-12);
          confusionMatrix[actual][predicted]++;
        }
      });
      
      totalAccuracy += foldCorrect / testSet.length;
      totalLogLikelihood += foldLogLikelihood / testSet.length;
    }
    
    // Calculate metrics
    const accuracy = totalAccuracy / folds;
    const logLikelihood = totalLogLikelihood / folds;
    
    // Precision, recall, F1 per class
    const metrics = [];
    for (let i = 0; i < this.nBins; i++) {
      const tp = confusionMatrix[i][i];
      const fp = confusionMatrix.reduce((sum, row, j) => i !== j ? sum + row[i] : sum, 0);
      const fn = confusionMatrix[i].reduce((sum, val, j) => i !== j ? sum + val : sum, 0);
      
      const precision = tp / (tp + fp) || 0;
      const recall = tp / (tp + fn) || 0;
      const f1 = 2 * precision * recall / (precision + recall) || 0;
      
      metrics.push({ precision, recall, f1 });
    }
    
    return {
      accuracy,
      logLikelihood,
      confusionMatrix,
      classMetrics: metrics,
      macroF1: metrics.reduce((sum, m) => sum + m.f1, 0) / metrics.length
    };
  }
}

/* ===================================================================
   UI STATE AND GLOBAL VARIABLES
   =================================================================== */

let network = new BayesianNetwork();
let uploadedData = [];
let charts = {};

// Default bins for price categories (will be updated from data)
let priceLabels = ['Low', 'Medium', 'High', 'Luxury'];
let priceCenters = [100000, 250000, 425000, 650000];

/* ===================================================================
   CHART INITIALIZATION
   =================================================================== */

function initCharts() {
  // Bar chart for probability distribution
  const barCtx = document.getElementById('barChart');
  if (barCtx) {
    charts.bar = new Chart(barCtx, {
      type: 'bar',
      data: {
        labels: priceLabels,
        datasets: [{
          label: 'Probability (%)',
          data: [25, 25, 25, 25],
          backgroundColor: ['#ef4444', '#f59e0b', '#10b981', '#8b5cf6'],
          borderColor: ['#dc2626', '#d97706', '#059669', '#7c3aed'],
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false }
        },
        scales: {
          y: { 
            beginAtZero: true, 
            max: 100,
            title: { display: true, text: 'Probability (%)' }
          }
        }
      }
    });
  }
  
  // Distribution chart (line chart for continuous view)
  const distCtx = document.getElementById('distributionChart');
  if (distCtx) {
    charts.distribution = new Chart(distCtx, {
      type: 'line',
      data: {
        labels: priceLabels,
        datasets: [{
          label: 'Posterior Distribution',
          data: [25, 25, 25, 25],
          borderColor: '#3b82f6',
          backgroundColor: 'rgba(59, 130, 246, 0.1)',
          fill: true,
          tension: 0.4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false }
        },
        scales: {
          y: { 
            beginAtZero: true,
            title: { display: true, text: 'Density' }
          }
        }
      }
    });
  }
}

/* ===================================================================
   MAP INITIALIZATION
   =================================================================== */

let map = null;
let marker = null;

function initMap() {
  try {
    map = L.map('mini-map', { 
      zoomControl: true, 
      attributionControl: false 
    }).setView([34.05, -118.25], 7);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
      maxZoom: 19 
    }).addTo(map);
    
    marker = L.marker([34.05, -118.25]).addTo(map);
  } catch (error) {
    console.error('Map initialization failed:', error);
  }
}

/* ===================================================================
   UI GENERATION FUNCTIONS
   =================================================================== */

function generateInputFields() {
  const container = document.getElementById('input-fields');
  if (!container) return;
  
  container.innerHTML = '';
  
  network.features.forEach(feature => {
    const div = document.createElement('div');
    div.innerHTML = `
      <label class="text-xs font-medium text-gray-700">${feature}</label>
      <input id="input-${feature}" type="number" step="any" 
             class="mt-1 p-2 w-full border rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500" 
             placeholder="Enter ${feature}" />
    `;
    container.appendChild(div);
  });
}

function generateSensitivitySliders() {
  const container = document.getElementById('sensitivity-sliders');
  if (!container) return;
  
  container.innerHTML = '';
  
  // Create sliders for first 3 features for space efficiency
  network.features.slice(0, 3).forEach(feature => {
    const thresholds = network.thresholds[feature] || [0, 100];
    const min = Math.min(...thresholds) - Math.abs(thresholds[0]) * 0.5;
    const max = Math.max(...thresholds) + Math.abs(thresholds[thresholds.length - 1]) * 0.5;
    const mid = (min + max) / 2;
    
    const div = document.createElement('div');
    div.innerHTML = `
      <label class="text-xs">${feature} sensitivity</label>
      <input id="slider-${feature}" type="range" min="${min}" max="${max}" step="${(max - min) / 100}" value="${mid}"
             class="w-full mt-1" />
      <div class="text-xs text-gray-600">Value: <span id="slider-${feature}-val">${MathUtils.round(mid)}</span></div>
    `;
    container.appendChild(div);
    
    // Add event listener
    const slider = div.querySelector(`#slider-${feature}`);
    const valueSpan = div.querySelector(`#slider-${feature}-val`);
    const input = document.getElementById(`input-${feature}`);
    
    slider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      valueSpan.textContent = MathUtils.round(value);
      if (input) input.value = value;
    });
  });
}

function generateProbabilityBars(posterior) {
  const container = document.getElementById('probability-bars');
  if (!container) return;
  
  container.innerHTML = '';
  
  const colors = ['#ef4444', '#f59e0b', '#10b981', '#8b5cf6'];
  
  posterior.forEach((prob, i) => {
    const percentage = prob * 100;
    const div = document.createElement('div');
    div.innerHTML = `
      <div class="flex justify-between mb-1">
        <span class="text-sm font-medium">${priceLabels[i]}</span>
        <span class="text-sm font-semibold">${MathUtils.round(percentage, 1)}%</span>
      </div>
      <div class="w-full bg-gray-200 rounded-full h-3 mb-3">
        <div class="probability-bar h-3 rounded-full" 
             style="width: ${percentage}%; background-color: ${colors[i]};"></div>
      </div>
    `;
    container.appendChild(div);
  });
}

/* ===================================================================
   MAIN INFERENCE FUNCTION
   =================================================================== */

function runInference() {
  if (!network.learned) {
    alert('Please upload and train on data first.');
    return;
  }
  
  // Collect evidence from input fields
  const evidence = {};
  network.features.forEach(feature => {
    const input = document.getElementById(`input-${feature}`);
    if (input && input.value !== '') {
      evidence[feature] = parseFloat(input.value);
    }
  });
  
  // Update map if location data available
  if (evidence.Latitude && evidence.Longitude && map && marker) {
    map.setView([evidence.Latitude, evidence.Longitude], 10);
    marker.setLatLng([evidence.Latitude, evidence.Longitude]);
  }
  
  const method = document.getElementById('inference-method').value;
  let posterior, methodText;
  
  if (method === 'exact') {
    posterior = network.inferExact(evidence);
    methodText = 'Variable Elimination (Exact)';
  } else {
    const iterations = parseInt(document.getElementById('gibbs-iterations').value) || 5000;
    posterior = network.inferMCMC(evidence, iterations);
    methodText = `Gibbs Sampling (${iterations} iterations)`;
  }
  
  updateUI(posterior, evidence, methodText);
}

function updateUI(posterior, evidence, methodText) {
  // Update charts
  if (charts.bar) {
    charts.bar.data.datasets[0].data = posterior.map(p => p * 100);
    charts.bar.update();
  }
  
  if (charts.distribution) {
    charts.distribution.data.datasets[0].data = posterior;
    charts.distribution.update();
  }
  
  // Update probability bars
  generateProbabilityBars(posterior);
  
  // Calculate expected value
  const expectedValue = posterior.reduce((sum, prob, i) => sum + prob * priceCenters[i], 0);
  document.getElementById('expected-value').textContent = `${Math.round(expectedValue).toLocaleString()}`;
  
  // Calculate confidence interval (approximate)
  const cumSum = [];
  let sum = 0;
  for (let p of posterior) {
    sum += p;
    cumSum.push(sum);
  }
  
  let lowerIdx = 0, upperIdx = posterior.length - 1;
  for (let i = 0; i < cumSum.length; i++) {
    if (cumSum[i] >= 0.05) { lowerIdx = i; break; }
  }
  for (let i = cumSum.length - 1; i >= 0; i--) {
    if (cumSum[i] <= 0.95) { upperIdx = i + 1; break; }
  }
  
  const lowerBound = lowerIdx < priceCenters.length ? priceCenters[lowerIdx] : priceCenters[0];
  const upperBound = upperIdx < priceCenters.length ? priceCenters[upperIdx] : priceCenters[priceCenters.length - 1];
  
  document.getElementById('confidence-interval').textContent = 
    `${Math.round(lowerBound).toLocaleString()} - ${Math.round(upperBound).toLocaleString()}`;
  
  // Calculate and display feature importance
  const importance = network.computeFeatureImportance(evidence);
  const woeDiv = document.getElementById('woe-list');
  woeDiv.innerHTML = '';
  
  importance.slice(0, 5).forEach(item => {
    const div = document.createElement('div');
    div.className = 'flex justify-between items-center py-1';
    div.innerHTML = `
      <span class="font-medium">${item.feature}</span>
      <span class="text-xs bg-green-100 px-2 py-1 rounded">${MathUtils.round(item.importance, 3)}</span>
    `;
    woeDiv.appendChild(div);
  });
  
  // Update diagnostics
  const entropy = MathUtils.entropy(posterior);
  const confidence = 1 - (entropy / Math.log2(posterior.length)); // Normalized confidence
  
  document.getElementById('inf-method-text').textContent = methodText;
  document.getElementById('evidence-text').textContent = 
    Object.keys(evidence).length ? Object.keys(evidence).join(', ') : 'No evidence';
  document.getElementById('entropy-text').textContent = MathUtils.round(entropy, 2);
  document.getElementById('confidence-text').textContent = `${MathUtils.round(confidence * 100, 1)}%`;
}

/* ===================================================================
   DATA UPLOAD AND TRAINING
   =================================================================== */

function handleDataUpload(file) {
  Papa.parse(file, {
    header: true,
    dynamicTyping: true,
    skipEmptyLines: true,
    complete: (results) => {
      uploadedData = results.data.filter(row => Object.keys(row).length > 0);
      
      if (uploadedData.length === 0) {
        alert('No valid data found in CSV file.');
        return;
      }
      
      console.log(`Loaded ${uploadedData.length} rows from CSV`);
      
      // Populate column selectors
      const headers = Object.keys(uploadedData[0] || {});
      const targetSelect = document.getElementById('target-column');
      const timeSelect = document.getElementById('time-column');
      
      [targetSelect, timeSelect].forEach(select => {
        if (select) {
          select.innerHTML = '<option value="">Select column...</option>';
          headers.forEach(header => {
            const option = document.createElement('option');
            option.value = header;
            option.textContent = header;
            select.appendChild(option);
          });
        }
      });
      
      // Auto-select likely target column
      const priceColumns = headers.filter(h => 
        h.toLowerCase().includes('price') || 
        h.toLowerCase().includes('value') ||
        h.toLowerCase().includes('cost')
      );
      
      if (priceColumns.length > 0 && targetSelect) {
        targetSelect.value = priceColumns[0];
      }
      
      alert(`Successfully loaded ${uploadedData.length} rows with ${headers.length} columns.`);
    },
    error: (error) => {
      alert(`Error parsing CSV: ${error.message}`);
    }
  });
}

function trainModel() {
  if (uploadedData.length === 0) {
    alert('Please upload data first.');
    return;
  }
  
  const targetCol = document.getElementById('target-column').value;
  const nBins = parseInt(document.getElementById('n-bins').value) || 4;
  const method = document.getElementById('discretization-method').value;
  
  if (!targetCol) {
    alert('Please select a target column.');
    return;
  }
  
  try {
    network = new BayesianNetwork();
    network.learnFromData(uploadedData, targetCol, nBins, method);
    
    // Update price labels and centers based on learned bins
    if (network.targetBins && network.targetBins.length > 0) {
      const bins = network.targetBins;
      priceCenters = [];
      priceLabels = [];
      
      // First bin
      priceCenters.push(bins[0] / 2);
      priceLabels.push(`Low (<${Math.round(bins[0]).toLocaleString()})`);
      
      // Middle bins
      for (let i = 0; i < bins.length - 1; i++) {
        priceCenters.push((bins[i] + bins[i + 1]) / 2);
        priceLabels.push(`Tier ${i + 2} (${Math.round(bins[i]).toLocaleString()}-${Math.round(bins[i + 1]).toLocaleString()})`);
      }
      
      // Last bin
      const lastBin = bins[bins.length - 1];
      priceCenters.push(lastBin * 1.3);
      priceLabels.push(`High (>${Math.round(lastBin).toLocaleString()})`);
    }
    
    // Regenerate UI components
    generateInputFields();
    generateSensitivitySliders();
    
    // Reinitialize charts with new labels
    initCharts();
    
    // Display learned model structure
    displayModelStructure();
    
    alert('Model training completed successfully!');
    
  } catch (error) {
    alert(`Training failed: ${error.message}`);
    console.error('Training error:', error);
  }
}

function displayModelStructure() {
  const preview = document.getElementById('cpt-preview');
  if (!preview) return;
  
  preview.innerHTML = '';
  
  // Prior distribution
  const priorDiv = document.createElement('div');
  priorDiv.innerHTML = `
    <div class="font-semibold mb-2">Prior Distribution P(${network.targetColumn})</div>
    <div class="text-xs mb-3">
      ${network.priorDist.map((p, i) => 
        `${priceLabels[i]}: ${MathUtils.round(p * 100, 1)}%`
      ).join(' | ')}
    </div>
  `;
  preview.appendChild(priorDiv);
  
  // Feature distributions (show first 3 for space)
  network.features.slice(0, 3).forEach(feature => {
    const div = document.createElement('div');
    div.innerHTML = `<div class="font-semibold mt-3 mb-1">P(${feature} | ${network.targetColumn})</div>`;
    
    const table = document.createElement('table');
    table.className = 'text-xs w-full border-collapse';
    table.innerHTML = `
      <tr class="bg-gray-100">
        <th class="border p-1">Target</th>
        <th class="border p-1">Low</th>
        <th class="border p-1">Med</th>
        <th class="border p-1">High</th>
      </tr>
    `;
    
    for (let targetBin = 0; targetBin < network.nBins; targetBin++) {
      const row = table.insertRow();
      row.innerHTML = `
        <td class="border p-1">${priceLabels[targetBin]}</td>
        ${network.conditionalDists[feature][targetBin].map(p => 
          `<td class="border p-1">${MathUtils.round(p, 2)}</td>`
        ).join('')}
      `;
    }
    
    div.appendChild(table);
    preview.appendChild(div);
  });
  
  if (network.features.length > 3) {
    const moreDiv = document.createElement('div');
    moreDiv.className = 'text-xs text-gray-500 mt-2';
    moreDiv.textContent = `... and ${network.features.length - 3} more features`;
    preview.appendChild(moreDiv);
  }
}

function evaluateModel() {
  if (!network.learned) {
    alert('Please train model first.');
    return;
  }
  
  try {
    const results = network.evaluate(uploadedData);
    const output = document.getElementById('eval-output');
    
    output.innerHTML = `
      <div class="space-y-2">
        <div class="bg-blue-50 p-3 rounded">
          <div class="font-semibold text-blue-800">Overall Performance</div>
          <div class="text-sm">
            <div>Cross-validation Accuracy: <span class="font-semibold">${MathUtils.round(results.accuracy * 100, 1)}%</span></div>
            <div>Log-likelihood: <span class="font-semibold">${MathUtils.round(results.logLikelihood, 3)}</span></div>
            <div>Macro F1-Score: <span class="font-semibold">${MathUtils.round(results.macroF1, 3)}</span></div>
          </div>
        </div>
        
        <div class="bg-green-50 p-3 rounded">
          <div class="font-semibold text-green-800">Per-Class Metrics</div>
          <div class="text-xs">
            ${results.classMetrics.map((metric, i) => `
              <div>${priceLabels[i]}: P=${MathUtils.round(metric.precision, 2)} R=${MathUtils.round(metric.recall, 2)} F1=${MathUtils.round(metric.f1, 2)}</div>
            `).join('')}
          </div>
        </div>
        
        <div class="bg-gray-50 p-3 rounded">
          <div class="font-semibold text-gray-800">Model Info</div>
          <div class="text-xs">
            <div>Features: ${network.features.length}</div>
            <div>Training samples: ${uploadedData.length}</div>
            <div>Target bins: ${network.nBins}</div>
          </div>
        </div>
      </div>
    `;
  } catch (error) {
    alert(`Evaluation failed: ${error.message}`);
  }
}

/* ===================================================================
   SCENARIO ANALYSIS FUNCTIONS
   =================================================================== */

function runBuilderScenario() {
  if (!network.learned) {
    alert('Please train model first.');
    return;
  }
  
  const evidence = collectEvidence();
  const cost = parseFloat(document.getElementById('builder-cost').value) || 0;
  const margin = parseFloat(document.getElementById('builder-margin').value) || 0;
  const premium = parseFloat(document.getElementById('builder-premium').value) || 1;
  
  const posterior = network.inferExact(evidence);
  const expectedPrice = posterior.reduce((sum, prob, i) => sum + prob * priceCenters[i], 0);
  const expectedRevenue = expectedPrice * premium;
  const expectedProfit = expectedRevenue - cost;
  const roi = cost > 0 ? (expectedProfit / cost) * 100 : 0;
  
  // Risk analysis
  const breakEvenPrice = cost / premium;
  let riskProb = 0;
  for (let i = 0; i < priceCenters.length; i++) {
    if (priceCenters[i] < breakEvenPrice) {
      riskProb += posterior[i];
    }
  }
  
  document.getElementById('builder-output').innerHTML = `
    <div class="space-y-2">
      <div><strong>Expected Sale Price:</strong> ${Math.round(expectedPrice).toLocaleString()}</div>
      <div><strong>Expected Revenue:</strong> ${Math.round(expectedRevenue).toLocaleString()}</div>
      <div><strong>Expected Profit:</strong> ${Math.round(expectedProfit).toLocaleString()}</div>
      <div><strong>ROI:</strong> ${MathUtils.round(roi, 1)}%</div>
      <div class="text-red-600"><strong>Loss Risk:</strong> ${MathUtils.round(riskProb * 100, 1)}%</div>
    </div>
  `;
}

function runBankScenario() {
  if (!network.learned) {
    alert('Please train model first.');
    return;
  }
  
  const evidence = collectEvidence();
  const loanAmount = parseFloat(document.getElementById('bank-loan').value) || 0;
  const ltv = parseFloat(document.getElementById('bank-ltv').value) || 80;
  const riskThreshold = parseFloat(document.getElementById('bank-risk').value) || 10;
  
  const posterior = network.inferExact(evidence);
  const expectedPrice = posterior.reduce((sum, prob, i) => sum + prob * priceCenters[i], 0);
  
  const requiredValue = loanAmount / (ltv / 100);
  let defaultRisk = 0;
  
  for (let i = 0; i < priceCenters.length; i++) {
    if (priceCenters[i] < requiredValue) {
      defaultRisk += posterior[i];
    }
  }
  
  const riskLevel = defaultRisk * 100 > riskThreshold ? 'HIGH' : 
                   defaultRisk * 100 > riskThreshold / 2 ? 'MEDIUM' : 'LOW';
  
  document.getElementById('bank-output').innerHTML = `
    <div class="space-y-2">
      <div><strong>Expected Property Value:</strong> ${Math.round(expectedPrice).toLocaleString()}</div>
      <div><strong>Required Value (LTV):</strong> ${Math.round(requiredValue).toLocaleString()}</div>
      <div><strong>Default Risk:</strong> ${MathUtils.round(defaultRisk * 100, 1)}%</div>
      <div class="font-semibold ${riskLevel === 'HIGH' ? 'text-red-600' : riskLevel === 'MEDIUM' ? 'text-yellow-600' : 'text-green-600'}">
        Risk Level: ${riskLevel}
      </div>
    </div>
  `;
}

function runPolicyScenario() {
  if (!network.learned) {
    alert('Please train model first.');
    return;
  }
  
  const baseEvidence = collectEvidence();
  const incomeChange = parseFloat(document.getElementById('policy-income').value) || 0;
  
  // Apply policy shock to income-related features
  const modifiedEvidence = { ...baseEvidence };
  network.features.forEach(feature => {
    if (feature.toLowerCase().includes('income') || feature.toLowerCase().includes('inc')) {
      if (modifiedEvidence[feature]) {
        modifiedEvidence[feature] *= (1 + incomeChange / 100);
      }
    }
  });
  
  const basePosterior = network.inferExact(baseEvidence);
  const modifiedPosterior = network.inferExact(modifiedEvidence);
  
  const changes = modifiedPosterior.map((p, i) => p - basePosterior[i]);
  const baseExpected = basePosterior.reduce((sum, prob, i) => sum + prob * priceCenters[i], 0);
  const modifiedExpected = modifiedPosterior.reduce((sum, prob, i) => sum + prob * priceCenters[i], 0);
  const priceImpact = ((modifiedExpected - baseExpected) / baseExpected) * 100;
  
  document.getElementById('policy-output').innerHTML = `
    <div class="space-y-2">
      <div><strong>Policy Impact Analysis</strong></div>
      <div>Income change: ${incomeChange > 0 ? '+' : ''}${incomeChange}%</div>
      <div>Expected price change: ${priceImpact > 0 ? '+' : ''}${MathUtils.round(priceImpact, 1)}%</div>
      <div class="text-xs">
        Probability shifts: ${changes.map(c => `${c > 0 ? '+' : ''}${MathUtils.round(c * 100, 1)}%`).join(', ')}
      </div>
    </div>
  `;
}

/* ===================================================================
   ADVANCED METHODS
   =================================================================== */

function runMCMCAnalysis() {
  if (!network.learned) {
    alert('Please train model first.');
    return;
  }
  
  const evidence = collectEvidence();
  const iterations = parseInt(document.getElementById('mcmc-iterations').value) || 10000;
  const burnin = parseFloat(document.getElementById('mcmc-burnin').value) / 100 || 0.25;
  const method = document.getElementById('mcmc-method').value || 'gibbs';
  
  const startTime = performance.now();
  const posterior = network.inferMCMC(evidence, iterations, burnin, method);
  const duration = performance.now() - startTime;
  
  // Compare with exact inference
  const exactPosterior = network.inferExact(evidence);
  const klDiv = MathUtils.klDivergence(exactPosterior, posterior);
  
  updateUI(posterior, evidence, `${method.toUpperCase()} MCMC (${iterations} iter)`);
  
  document.getElementById('mcmc-output').innerHTML = `
    <div class="space-y-2">
      <div><strong>MCMC Results</strong></div>
      <div>Runtime: ${MathUtils.round(duration, 0)}ms</div>
      <div>KL divergence from exact: ${MathUtils.round(klDiv, 4)}</div>
      <div>Effective sample size: ~${Math.round(iterations * (1 - burnin))}</div>
      <div class="text-xs">Posterior: ${posterior.map(p => MathUtils.round(p, 3)).join(', ')}</div>
    </div>
  `;
}

/* ===================================================================
   UTILITY FUNCTIONS
   =================================================================== */

function collectEvidence() {
  const evidence = {};
  network.features.forEach(feature => {
    const input = document.getElementById(`input-${feature}`);
    if (input && input.value !== '') {
      evidence[feature] = parseFloat(input.value);
    }
  });
  return evidence;
}

function saveAnalysis() {
  if (!network.learned) {
    alert('No model to save.');
    return;
  }
  
  const evidence = collectEvidence();
  const method = document.getElementById('inference-method').value;
  const name = document.getElementById('run-name').value || `Analysis ${new Date().toLocaleString()}`;
  
  const posterior = method === 'exact' ? 
    network.inferExact(evidence) : 
    network.inferMCMC(evidence, parseInt(document.getElementById('gibbs-iterations').value) || 5000);
  
  const expectedValue = posterior.reduce((sum, prob, i) => sum + prob * priceCenters[i], 0);
  
  const analysis = {
    name,
    timestamp: new Date().toISOString(),
    method: method === 'exact' ? 'Variable Elimination' : 'MCMC Gibbs',
    evidence,
    posterior,
    expectedValue
  };
  
  const history = JSON.parse(localStorage.getItem('bhp_analyses') || '[]');
  history.push(analysis);
  localStorage.setItem('bhp_analyses', JSON.stringify(history));
  
  updateHistoryDisplay();
  alert('Analysis saved successfully!');
}

function updateHistoryDisplay() {
  const container = document.getElementById('history-quick');
  if (!container) return;
  
  const history = JSON.parse(localStorage.getItem('bhp_analyses') || '[]');
  
  container.innerHTML = '';
  
  if (history.length === 0) {
    container.innerHTML = '<div class="text-xs text-gray-500 p-2">No saved analyses</div>';
    return;
  }
  
  history.slice(-5).reverse().forEach((analysis, idx) => {
    const div = document.createElement('div');
    div.className = 'p-2 border-b border-gray-200 hover:bg-gray-50 cursor-pointer text-xs';
    div.innerHTML = `
      <div class="font-semibold">${analysis.name}</div>
      <div class="text-gray-600">Expected: ${Math.round(analysis.expectedValue).toLocaleString()}</div>
      <div class="text-gray-500">${new Date(analysis.timestamp).toLocaleString()}</div>
    `;
    
    div.addEventListener('click', () => {
      // Load analysis
      Object.keys(analysis.evidence).forEach(feature => {
        const input = document.getElementById(`input-${feature}`);
        if (input) input.value = analysis.evidence[feature];
      });
      
      updateUI(analysis.posterior, analysis.evidence, `Loaded: ${analysis.method}`);
    });
    
    container.appendChild(div);
  });
}

function exportResults() {
  const history = JSON.parse(localStorage.getItem('bhp_analyses') || '[]');
  if (history.length === 0) {
    alert('No analyses to export.');
    return;
  }
  
  // Convert to CSV format
  const headers = ['name', 'timestamp', 'method', 'expectedValue', ...network.features, ...priceLabels.map(label => `prob_${label}`)];
  const rows = [headers];
  
  history.forEach(analysis => {
    const row = [
      analysis.name,
      analysis.timestamp,
      analysis.method,
      analysis.expectedValue
    ];
    
    // Add feature values
    network.features.forEach(feature => {
      row.push(analysis.evidence[feature] || '');
    });
    
    // Add probabilities
    analysis.posterior.forEach(prob => {
      row.push(prob);
    });
    
    rows.push(row);
  });
  
  const csv = rows.map(row => row.join(',')).join('\n');
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = `bayesian_housing_analysis_${Date.now()}.csv`;
  a.click();
  
  URL.revokeObjectURL(url);
}

function exportPDF() {
  const history = JSON.parse(localStorage.getItem('bhp_analyses') || '[]');
  if (history.length === 0) {
    alert('No analyses to export.');
    return;
  }
  
  const { jsPDF } = window.jspdf;
  const doc = new jsPDF();
  
  // Title
  doc.setFontSize(16);
  doc.text('Bayesian Housing Price Analysis Report', 20, 20);
  
  doc.setFontSize(10);
  doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 30);
  doc.text(`Model: ${network.features.length} features, ${network.nBins} price bins`, 20, 35);
  
  let y = 50;
  
  history.slice(-5).forEach((analysis, idx) => {
    if (y > 250) {
      doc.addPage();
      y = 20;
    }
    
    doc.setFontSize(12);
    doc.text(`Analysis: ${analysis.name}`, 20, y);
    y += 10;
    
    doc.setFontSize(9);
    doc.text(`Method: ${analysis.method}`, 20, y);
    doc.text(`Expected Value: ${Math.round(analysis.expectedValue).toLocaleString()}`, 100, y);
    y += 8;
    
    doc.text('Probabilities:', 20, y);
    y += 5;
    analysis.posterior.forEach((prob, i) => {
      doc.text(`${priceLabels[i]}: ${MathUtils.round(prob * 100, 1)}%`, 30, y);
      y += 5;
    });
    
    y += 10;
  });
  
  doc.save(`bayesian_housing_report_${Date.now()}.pdf`);
}

/* ===================================================================
   EVENT LISTENERS AND INITIALIZATION
   =================================================================== */

document.addEventListener('DOMContentLoaded', function() {
  // Initialize components
  initCharts();
  initMap();
  updateHistoryDisplay();
  
  // Main functionality
  document.getElementById('btn-run')?.addEventListener('click', runInference);
  document.getElementById('csv-file')?.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) handleDataUpload(file);
  });
  
  // Training
  document.getElementById('btn-learn')?.addEventListener('click', trainModel);
  document.getElementById('btn-eval')?.addEventListener('click', evaluateModel);
  
  // Scenarios
  document.getElementById('btn-builder-sim')?.addEventListener('click', runBuilderScenario);
  document.getElementById('btn-bank-sim')?.addEventListener('click', runBankScenario);
  document.getElementById('btn-policy-sim')?.addEventListener('click', runPolicyScenario);
  
  // Advanced
  document.getElementById('btn-mcmc-run')?.addEventListener('click', runMCMCAnalysis);
  
  // History and export
  document.getElementById('btn-save-history')?.addEventListener('click', saveAnalysis);
  document.getElementById('btn-clear-history')?.addEventListener('click', () => {
    localStorage.removeItem('bhp_analyses');
    updateHistoryDisplay();
  });
  document.getElementById('btn-export-csv')?.addEventListener('click', exportResults);
  document.getElementById('btn-export-pdf')?.addEventListener('click', exportPDF);
  
  // Set some default values for demo
  setTimeout(() => {
    // Pre-populate some reasonable default values
    if (network.features.length === 0) {
      // Create demo features for initial display
      network.features = ['MedInc', 'HouseAge', 'AveRooms', 'Population', 'Latitude', 'Longitude'];
      network.thresholds = {
        'MedInc': [2.5, 5.0],
        'HouseAge': [10, 30],
        'AveRooms': [4, 6],
        'Population': [1000, 3000],
        'Latitude': [33, 35],
        'Longitude': [-120, -117]
      };
      generateInputFields();
      generateSensitivitySliders();
    }
  }, 100);
});

// Handle window resize for charts
window.addEventListener('resize', () => {
  Object.values(charts).forEach(chart => {
    if (chart && chart.resize) chart.resize();
  });
  
  if (map) {
    setTimeout(() => map.invalidateSize(), 100);
  }
});

</script>
</body>
</html>